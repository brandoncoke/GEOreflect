(qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
exprs(gset) <- log2(ex) }
# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("1","2"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)
fit <- lmFit(gset, design)  # fit linear model
# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups[1], groups[2], sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=5000000)
tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC", "Gene.ID",
"Gene.symbol","Gene.title"))
average_exprss= as.data.frame(apply(ex, 1, sum, na.rm= T))
average_exprss$ID= rownames(average_exprss)
tT= merge(tT, average_exprss)
View(tT)
#same procedure as GEO2R
fvarLabels(gset) <- make.names(fvarLabels(gset))
sml <- strsplit(gsms, split="")[[1]]
# filter out excluded samples (marked as "X")
sel <- which(sml != "X")
sml <- sml[sel]
gset <- gset[ ,sel]
# log2 transformation
ex <- exprs(gset)
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
(qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
exprs(gset) <- log2(ex) }
# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("1","2"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)
fit <- lmFit(gset, design)  # fit linear model
# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups[1], groups[2], sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=5000000)
tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC", "Gene.ID",
"Gene.symbol","Gene.title"))
average_exprss= as.data.frame(apply(ex, 1, sum, na.rm= T))
average_exprss$ID= rownames(average_exprss)
colnames(average_exprss)[1]= "average_exprss"
tT= merge(tT, average_exprss)
View(tT)
the_frame
the_frame= get_DEG_table(gset = gset,
gsms= gsms)
colnames(the_frame)
get_DEG_table= function(gset, gsms){
#same procedure as GEO2R
fvarLabels(gset) <- make.names(fvarLabels(gset))
sml <- strsplit(gsms, split="")[[1]]
# filter out excluded samples (marked as "X")
sel <- which(sml != "X")
sml <- sml[sel]
gset <- gset[ ,sel]
# log2 transformation
ex <- exprs(gset)
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
(qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
exprs(gset) <- log2(ex) }
# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("1","2"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)
fit <- lmFit(gset, design)  # fit linear model
# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups[1], groups[2], sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=5000000)
tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC", "Gene.ID",
"Gene.symbol","Gene.title"))
average_exprss= as.data.frame(apply(ex, 1, sum, na.rm= T))
average_exprss$ID= rownames(average_exprss)
colnames(average_exprss)[1]= "average_exprss"
tT= merge(tT, average_exprss)
return(tT)
}
the_frame= get_DEG_table(gset = gset,
gsms= gsms)
colnames(the_frame)
the_frame= the_frame[c("ID", "P.Value",
"logFC", "Gene.symbol",
"average_exprss")]
the_frame
unmatched_bool= T
minlogfc= -1
pvallim= 0.05
maxlogfc=1
merge_probe_gene= F
colnames(temp)= c("probe", "pvalues", "logfc", "genes")
temp= temp[!is.na(temp$logfc) &
!is.na(temp$pvalues), ]
temp= the_frame
colnames(temp)= c("probe", "pvalues", "logfc", "genes",
"average_exprss")
temp= temp[!is.na(temp$logfc) &
!is.na(temp$pvalues), ]
temp= temp[temp$logfc < minlogfc | temp$logfc >
maxlogfc, ]
temp= temp[temp$pvalues <= pvallim, ]
if(unmatched_bool){
temp= temp[temp$genes %in% rownames(percentile_matrix_p_value_RNAseq), ]
}
temp$pval_normalised= rank(-temp$pvalues)/(length(temp$pvalues))
temp$aver_exprss_normalised= rank(temp$average_exprss)/(length(temp$average_exprss))
View(temp)
temp$plat_rank= as.integer(apply(temp, 1,
get_platform_percentile_GPL570))
load('percentile_matrix.RDS')
get_platform_percentile_GPL570= function(probe_and_pvalue= c("222589_at", 4.43E-09)){
if(as.numeric(probe_and_pvalue[2])== 0 |
!(probe_and_pvalue[1] %in% rownames(percentile_matrix))){
return(1)
}else{
gene= c(t(probe_and_pvalue[1])) #why does this work no clue but gets the string i need- t is transpose so eh#
which.min(as.numeric(percentile_matrix[rownames(percentile_matrix) == gene, ]) <
as.numeric(probe_and_pvalue[2])) #why do I need to coerce to float- how knows but safer as input can be treated as a string
}
}
temp$pval_normalised= rank(-temp$pvalues)/(length(temp$pvalues))
temp$aver_exprss_normalised= rank(temp$average_exprss)/(length(temp$average_exprss))
temp$plat_rank= as.integer(apply(temp, 1,
get_platform_percentile_GPL570))
temp$comb_score= apply(temp[,c("pval_normalised",
"aver_exprss_normalised",
"GEOreflect")], 1, geometric_mean)
temp$GEOreflect= ((1000 - temp$plat_rank)+1)/ 1000
temp$comb_score= apply(temp[,c("pval_normalised",
"aver_exprss_normalised",
"GEOreflect")], 1, geometric_mean)
View(temp)
output= data.frame(Probe= temp$probe,
Genes= temp$gene,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
Platform_relative_rank= temp$plat_rank,
Average_expression_rank= temp$average_exprss,
GEOreflect_rank= rank(-temp$comb_score))
runApp('app_gpl570.R')
shiny::runApp()
runApp('app_gpl570.R')
runApp('app_gpl570.R')
gset <- getGEO("GSE113970", GSEMatrix =T, AnnotGPL=T)
if(length(gset) > 1 & any(grepl("GPL570", attr(gset, "names")))){
idx= grep('GPL570', attr(gset, "names")) #bit of a bodge but assumes platform specified is enough to distinguish similar ones
}else{
idx= 1}
gset <- gset[[idx]]
# make proper column names to match toptable
fvarLabels(gset) <- make.names(fvarLabels(gset))
df= data.frame(GEO_id= as.character(gset@phenoData@data$geo_accession),
Title= as.character(gset@phenoData@data$title),
Source= as.character(gset@phenoData@data$source_name_ch1),
Characteristics= as.character(
gset@phenoData@data$characteristics_ch1))
df
apply(df, 1, paste0)
apply(df, 1, paste0, collapse= "")
as.character(apply(df, 1, paste0, collapse= ""))
runApp('app_gpl570.R')
load('percentile_matrix.RDS')
runApp('app_gpl570.R')
load('percentile_matrix.RDS')
get_platform_percentile_GPL570= function(probe_and_pvalue= c("222589_at", 4.43E-09)){
if(as.numeric(probe_and_pvalue[2])== 0 |
!(probe_and_pvalue[1] %in% rownames(percentile_matrix))){
return(1)
}else{
gene= c(t(probe_and_pvalue[1])) #why does this work no clue but gets the string i need- t is transpose so eh#
which.min(as.numeric(percentile_matrix[rownames(percentile_matrix) == gene, ]) <
as.numeric(probe_and_pvalue[2])) #why do I need to coerce to float- how knows but safer as input can be treated as a string
}
}
geometric_mean= function(values= c(1,2,1)){
(prod(values))^(1/length(values))
}
GEOreflect_reranking_GPL570= function(the_frame,
unmatched_bool= T,
minlogfc= -1,
pvallim= 0.05,
maxlogfc=1,
merge_probe_gene= F){
temp= the_frame
colnames(temp)= c("probe", "pvalues", "logfc", "genes",
"average_exprss")
if(class(temp$pvalues) != "numeric" |
class(temp$logfc) != "numeric" |
class(temp$probe) != "character" |
sum(is.na(temp$pvalues) == nrow(temp))){
return(data.frame(Genes= temp$genes,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
GEOreflect_rank= NA,
Rank_change= NA,
Shift= NA,
Platform_relative_rank= NA
))
}else{
temp= temp[!is.na(temp$logfc) &
!is.na(temp$pvalues), ]
temp= temp[temp$logfc < minlogfc | temp$logfc >
maxlogfc, ]
temp= temp[temp$pvalues <= pvallim, ]
if(unmatched_bool){
temp= temp[temp$genes %in% rownames(percentile_matrix), ]
}
if(!any(temp$genes %in% rownames(percentile_matrix))
| nrow(temp) == 0){
if(nrow(temp) == 0){
showModal(modalDialog(
title = "Filtering step too stringent",
paste0("Increase the p-value limit or bounds for upper and lower log fold change"),
easyClose = TRUE,
footer = NULL
))
}
return(data.frame(Probe= temp$probe,
Genes= temp$genes,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
GEOreflect_rank= NA,
Rank_change= NA,
Shift= NA,
Platform_relative_rank= NA
))
}else{
temp$pval_normalised= rank(-temp$pvalues)/(length(temp$pvalues))
temp$aver_exprss_normalised= rank(temp$average_exprss)/(length(temp$average_exprss))
temp$plat_rank= as.integer(apply(temp, 1,
get_platform_percentile_GPL570))
temp$GEOreflect= ((1000 - temp$plat_rank)+1)/ 1000
temp$comb_score= apply(temp[,c("pval_normalised",
"aver_exprss_normalised",
"GEOreflect")], 1, geometric_mean)
output= data.frame(Probe= temp$probe,
Genes= temp$gene,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
Platform_relative_rank= temp$plat_rank,
Average_expression_rank= temp$average_exprss,
GEOreflect_rank= rank(-temp$comb_score))
median_shift= as.numeric(
quantile(abs(output$pval_rank - output$GEOreflect_rank),
0.75))
output= output[order(output$GEOreflect_rank),]
output$Rank_change= output$GEOreflect_rank - output$pval_rank
output$Shift= apply(output, 1, shift_label, median_shift)
if(merge_probe_gene){
output$Genes= paste0(output$Genes, ": ", output$Probe)
}
return(output)
}
}
}
get_DEG_table= function(gset, gsms){
#same procedure as GEO2R
fvarLabels(gset) <- make.names(fvarLabels(gset))
sml <- strsplit(gsms, split="")[[1]]
# filter out excluded samples (marked as "X")
sel <- which(sml != "X")
sml <- sml[sel]
gset <- gset[ ,sel]
# log2 transformation
ex <- exprs(gset)
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
(qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
exprs(gset) <- log2(ex) }
# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("1","2"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)
fit <- lmFit(gset, design)  # fit linear model
# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups[1], groups[2], sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=5000000)
tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC", "Gene.ID",
"Gene.symbol","Gene.title"))
average_exprss= as.data.frame(apply(ex, 1, sum, na.rm= T))
average_exprss$ID= rownames(average_exprss)
colnames(average_exprss)[1]= "average_exprss"
tT= merge(tT, average_exprss)
return(tT)
}
treated_labels = c("overexp", "express", "transgen", "expos", "tg", "induc",
"stim", "treated", "transfected", "overexpression",
"transformed", "tumor", "tomour", "disease",
"infect", "disorder",
"knock", "null",
"s[hi]rna",
"delet",
"si[a-zA-z]",
"reduc",
"kd",
"\\-\\/",
"\\/\\-",
"\\+\\/", "\\/\\+",
"cre", "flox",
"mut",
"defici",
"[_| ]ko[_| ]|[_| ]ko$")
control_labels <- c("untreat", "_ns_",
"normal",
"^wt$|^wt[_| ]|[_| ]wt[_| ]|[_| ]wt$",
"gfp",
"non[-|.|_| ]smoker",
"vehicle",
"sensitive",
"stable",
"ctrl",
"non.sense",
"nonsense",
"baseline",
"mock",
"_luc_|_luc",
"siluc",
"wildtype|wild.type",
"nontreat",
"non.treated",
"control",
"[ |_]con[ |_]|^con$|^con[_| ]|[_| ]con$", #con sometimes stand in for control- needs to be specific- no futher words before or after
"untreated",
"no.treat",
"undosed",
"reference",
"standard",
"untransfected",
"mir.nc",
"minc",
"_non_|^non_",
"scramble",
"lucif",
"parent",
"free.medi",
"untransfected",
"ntc",
"mirNC")
GEO_id="GSE17385"
gset= getGEO(GEO_id, GSEMatrix =T, AnnotGPL=T)
if(length(gset) > 1 & any(grepl("GPL570", attr(gset, "names")))){
idx= grep('GPL570', attr(gset, "names")) #bit of a bodge but assumes platform specified is enough to distinguish similar ones
}else{
idx= 1}
gset <- gset[[idx]]
# make proper column names to match toptable
fvarLabels(gset) <- make.names(fvarLabels(gset))
GEO_ids= as.character(gset@phenoData@data$geo_accession)
gsms= rep("X", length(GEO_ids))
gsms[which(GEO_ids %in% input$CTRL_cols)]= 0
as.character(gset@phenoData@data$geo_accession)
gsms[1:3]= 0
gsms[4:6]= 1
gsms= paste0(gsms, collapse= "")
gsms
the_frame= get_DEG_table(gset = gset,
gsms= gsms)
the_frame
the_frame= the_frame[c("ID", "P.Value",
"logFC", "Gene.symbol",
"average_exprss")]
output= GEOreflect_reranking_GPL570(the_frame= the_frame,
unmatched_bool= input$unmatched,
minlogfc= input$minlogfc,
pvallim= input$pvallim,
maxlogfc= input$maxlogfc,
merge_probe_gene= F)
output= GEOreflect_reranking_GPL570(the_frame= the_frame)
View(the_frame)
GEOreflect_reranking_GPL570= function(the_frame,
unmatched_bool= T,
minlogfc= -1,
pvallim= 0.05,
maxlogfc=1,
merge_probe_gene= F){
temp= the_frame
colnames(temp)= c("probe", "pvalues", "logfc", "genes",
"average_exprss")
if(class(temp$pvalues) != "numeric" |
class(temp$logfc) != "numeric" |
class(temp$probe) != "character" |
sum(is.na(temp$pvalues) == nrow(temp))){
return(data.frame(Genes= temp$genes,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
GEOreflect_rank= NA,
Rank_change= NA,
Shift= NA,
Platform_relative_rank= NA
))
}else{
temp= temp[!is.na(temp$logfc) &
!is.na(temp$pvalues), ]
temp= temp[temp$logfc < minlogfc | temp$logfc >
maxlogfc, ]
temp= temp[temp$pvalues <= pvallim, ]
if(unmatched_bool){
temp= temp[temp$genes %in% rownames(percentile_matrix), ]
}
if(!any(temp$genes %in% rownames(percentile_matrix))
| nrow(temp) == 0){
if(nrow(temp) == 0){
#showModal(modalDialog(
#  title = "Filtering step too stringent",
#  paste0("Increase the p-value limit or bounds for upper and lower log fold change"),
#  easyClose = TRUE,
#  footer = NULL
#))
}
return(data.frame(Probe= temp$probe,
Genes= temp$genes,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
GEOreflect_rank= NA,
Rank_change= NA,
Shift= NA,
Platform_relative_rank= NA
))
}else{
temp$pval_normalised= rank(-temp$pvalues)/(length(temp$pvalues))
temp$aver_exprss_normalised= rank(temp$average_exprss)/(length(temp$average_exprss))
temp$plat_rank= as.integer(apply(temp, 1,
get_platform_percentile_GPL570))
temp$GEOreflect= ((1000 - temp$plat_rank)+1)/ 1000
temp$comb_score= apply(temp[,c("pval_normalised",
"aver_exprss_normalised",
"GEOreflect")], 1, geometric_mean)
output= data.frame(Probe= temp$probe,
Genes= temp$gene,
logFC= temp$logfc,
'p-values'= temp$pvalues,
pval_rank= rank(temp$pvalues),
Platform_relative_rank= temp$plat_rank,
Average_expression_rank= temp$average_exprss,
GEOreflect_rank= rank(-temp$comb_score))
median_shift= as.numeric(
quantile(abs(output$pval_rank - output$GEOreflect_rank),
0.75))
output= output[order(output$GEOreflect_rank),]
output$Rank_change= output$GEOreflect_rank - output$pval_rank
output$Shift= apply(output, 1, shift_label, median_shift)
if(merge_probe_gene){
output$Genes= paste0(output$Genes, ": ", output$Probe)
}
return(output)
}
}
}
GEOreflect_reranking_GPL570(the_frame = )
GEOreflect_reranking_GPL570(the_frame)
unmatched_bool= T
minlogfc= -1
pvallim= 0.05
maxlogfc=1
merge_probe_gene= F
temp= the_frame
colnames(temp)= c("probe", "pvalues", "logfc", "genes",
"average_exprss")
class(temp$pvalues) != "numeric" |
class(temp$logfc) != "numeric" |
class(temp$probe) != "character" |
sum(is.na(temp$pvalues) == nrow(temp))
temp= temp[!is.na(temp$logfc) &
!is.na(temp$pvalues), ]
temp= temp[temp$logfc < minlogfc | temp$logfc >
maxlogfc, ]
temp= temp[temp$pvalues <= pvallim, ]
runApp('app_gpl570.R')
runApp()
runApp('app_gpl570.R')
#?selectizeInput
?selectizeInput
runApp('app_gpl570.R')
runApp()
